"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/contracts/deployments directory to retrieve 
  deployment information for CardFusion.sol:
  
  - <root>/abi/CardFusionABI.ts
  - <root>/abi/CardFusionAddresses.ts
*/
import { CardFusionAddresses } from "@/abi/CardFusionAddresses";
import { CardFusionABI } from "@/abi/CardFusionABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

export type CardAttributes = {
  attack: ClearValueType | undefined;
  defense: ClearValueType | undefined;
  rarity: ClearValueType | undefined;
  specialPower: ClearValueType | undefined;
};

type CardFusionInfoType = {
  abi: typeof CardFusionABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves CardFusion contract metadata for the given EVM `chainId`.
 */
function getCardFusionByChainId(
  chainId: number | undefined
): CardFusionInfoType {
  if (!chainId) {
    return { abi: CardFusionABI.abi };
  }

  const entry =
    CardFusionAddresses[chainId.toString() as keyof typeof CardFusionAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: CardFusionABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: CardFusionABI.abi,
  };
}

export const useCardFusion = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  const [myCards, setMyCards] = useState<bigint[]>([]);
  const [cardAttributes, setCardAttributes] = useState<
    Map<bigint, CardAttributes>
  >(new Map());
  const [isMinting, setIsMinting] = useState<boolean>(false);
  const [isFusing, setIsFusing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const cardFusionRef = useRef<CardFusionInfoType | undefined>(undefined);
  const isMintingRef = useRef<boolean>(isMinting);
  const isFusingRef = useRef<boolean>(isFusing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isRefreshingRef = useRef<boolean>(isRefreshing);

  //////////////////////////////////////////////////////////////////////////////
  // CardFusion Contract
  //////////////////////////////////////////////////////////////////////////////

  const cardFusion = useMemo(() => {
    const c = getCardFusionByChainId(chainId);

    cardFusionRef.current = c;

    // Only show message when chainId is known and address is not configured
    if (chainId !== undefined && !c.address) {
      setMessage(`CardFusion contract is not deployed on this network. Please switch to a supported network.`);
    } else {
      // Clear message when chainId is undefined or address is available
      setMessage("");
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Status
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!cardFusion) {
      return undefined;
    }
    return (
      Boolean(cardFusion.address) && cardFusion.address !== ethers.ZeroAddress
    );
  }, [cardFusion]);

  const canMint = useMemo(() => {
    return (
      cardFusion.address &&
      instance &&
      ethersSigner &&
      !isMinting &&
      !isRefreshing
    );
  }, [cardFusion.address, instance, ethersSigner, isMinting, isRefreshing]);

  const canFuse = useMemo(() => {
    return (
      cardFusion.address &&
      instance &&
      ethersSigner &&
      !isFusing &&
      !isRefreshing &&
      myCards.length >= 2
    );
  }, [
    cardFusion.address,
    instance,
    ethersSigner,
    isFusing,
    isRefreshing,
    myCards.length,
  ]);

  const canDecrypt = useMemo(() => {
    return (
      cardFusion.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting
    );
  }, [
    cardFusion.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Refresh My Cards
  //////////////////////////////////////////////////////////////////////////////

  const refreshMyCards = useCallback(() => {
    console.log("[useCardFusion] call refreshMyCards()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !cardFusionRef.current ||
      !cardFusionRef.current?.chainId ||
      !cardFusionRef.current?.address ||
      !ethersReadonlyProvider ||
      !ethersSigner
    ) {
      setMyCards([]);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = cardFusionRef.current.chainId;
    const thisCardFusionAddress = cardFusionRef.current.address;

    const thisCardFusionContract = new ethers.Contract(
      thisCardFusionAddress,
      cardFusionRef.current.abi,
      ethersReadonlyProvider
    );

    ethersSigner
      .getAddress()
      .then((address) => {
        return thisCardFusionContract.balanceOf(address);
      })
      .then((balance: bigint) => {
        if (balance === 0n) {
          setMyCards([]);
          isRefreshingRef.current = false;
          setIsRefreshing(false);
          return;
        }

        const promises: Promise<bigint>[] = [];
        for (let i = 0; i < Number(balance); i++) {
          promises.push(
            thisCardFusionContract.tokenOfOwnerByIndex(
              ethersSigner.address,
              i
            )
          );
        }

        return Promise.all(promises);
      })
      .then((tokenIds: bigint[] | undefined) => {
        if (!tokenIds) {
          isRefreshingRef.current = false;
          setIsRefreshing(false);
          return;
        }
        console.log("[useCardFusion] tokenIds=" + tokenIds);
        if (
          sameChain.current(thisChainId) &&
          thisCardFusionAddress === cardFusionRef.current?.address
        ) {
          setMyCards(tokenIds);
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("Failed to load your cards. Please try refreshing the page.");

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain]);

  // Auto refresh the cards
  useEffect(() => {
    refreshMyCards();
  }, [refreshMyCards]);

  //////////////////////////////////////////////////////////////////////////////
  // Mint Card
  //////////////////////////////////////////////////////////////////////////////

  const mintCard = useCallback(
    (attack: number, defense: number, rarity: number, specialPower: number) => {
      if (isMintingRef.current || isRefreshingRef.current) {
        return;
      }

      if (!cardFusion.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisCardFusionAddress = cardFusion.address;
      const thisEthersSigner = ethersSigner;
      const thisCardFusionContract = new ethers.Contract(
        thisCardFusionAddress,
        cardFusion.abi,
        thisEthersSigner
      );

      isMintingRef.current = true;
      setIsMinting(true);
      setMessage(`Preparing to mint your card...`);

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisCardFusionAddress !== cardFusionRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisCardFusionAddress,
            thisEthersSigner.address
          );
          input.add32(attack);
          input.add32(defense);
          input.add32(rarity);
          input.add32(specialPower);

          const enc = await input.encrypt();

          if (isStale()) {
            setMessage(`Minting operation cancelled`);
            return;
          }

          setMessage(`Creating encrypted card data...`);

          const tx: ethers.TransactionResponse =
            await thisCardFusionContract.mintCard(
              thisEthersSigner.address,
              enc.handles[0],
              enc.handles[1],
              enc.handles[2],
              enc.handles[3],
              enc.inputProof
            );

          setMessage(`Transaction submitted! Waiting for confirmation...`);

          const receipt = await tx.wait();

          if (receipt?.status === 1) {
            setMessage(`Card minted successfully!`);
          } else {
            setMessage(`Minting transaction completed but failed`);
          }

          if (isStale()) {
            setMessage(`Minting operation cancelled`);
            return;
          }

          refreshMyCards();
        } catch (e) {
          setMessage(`Minting failed. Please try again.`);
        } finally {
          isMintingRef.current = false;
          setIsMinting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      cardFusion.address,
      cardFusion.abi,
      instance,
      chainId,
      refreshMyCards,
      sameChain,
      sameSigner,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Fuse Cards
  //////////////////////////////////////////////////////////////////////////////

  const fuseCards = useCallback(
    (cardId1: bigint, cardId2: bigint) => {
      if (isFusingRef.current || isRefreshingRef.current) {
        return;
      }

      if (!cardFusion.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisCardFusionAddress = cardFusion.address;
      const thisEthersSigner = ethersSigner;
      const thisCardFusionContract = new ethers.Contract(
        thisCardFusionAddress,
        cardFusion.abi,
        thisEthersSigner
      );

      isFusingRef.current = true;
      setIsFusing(true);
      setMessage(`Preparing to fuse your cards...`);

      const run = async () => {
        const isStale = () =>
          thisCardFusionAddress !== cardFusionRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          setMessage(`Initiating fusion process...`);

          const tx: ethers.TransactionResponse =
            await thisCardFusionContract.fuseCards(cardId1, cardId2);

          setMessage(`Transaction submitted! Waiting for confirmation...`);

          const receipt = await tx.wait();

          if (receipt?.status === 1) {
            setMessage(`Cards fused successfully! New card created.`);
          } else {
            setMessage(`Fusion transaction completed but failed`);
          }

          if (isStale()) {
            setMessage(`Fusion operation cancelled`);
            return;
          }

          refreshMyCards();
        } catch (e) {
          setMessage(`Fusion failed. Please try again.`);
        } finally {
          isFusingRef.current = false;
          setIsFusing(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      cardFusion.address,
      cardFusion.abi,
      instance,
      chainId,
      refreshMyCards,
      sameChain,
      sameSigner,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Decrypt Card Attributes
  //////////////////////////////////////////////////////////////////////////////

  const decryptCardAttributes = useCallback(
    (cardId: bigint) => {
      if (isRefreshingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!cardFusion.address || !instance || !ethersSigner) {
        return;
      }

      // Already decrypted
      if (cardAttributes.has(cardId)) {
        return;
      }

      const thisChainId = chainId;
      const thisCardFusionAddress = cardFusion.address;
      const thisCardId = cardId;
      const thisEthersSigner = ethersSigner;

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage("Preparing to decrypt card attributes...");

      const run = async () => {
        const isStale = () =>
          thisCardFusionAddress !== cardFusionRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const thisCardFusionContract = new ethers.Contract(
            thisCardFusionAddress,
            cardFusion.abi,
            ethersReadonlyProvider
          );

          const [attackHandle, defenseHandle, rarityHandle, specialPowerHandle] =
            await thisCardFusionContract.getCardAttributes(thisCardId);

          const sig: FhevmDecryptionSignature | null =
            await FhevmDecryptionSignature.loadOrSign(
              instance,
              [cardFusion.address as `0x${string}`],
              ethersSigner,
              fhevmDecryptionSignatureStorage
            );

          if (!sig) {
            setMessage("Unable to generate decryption signature. Please try again.");
            return;
          }

          if (isStale()) {
            setMessage("Decryption operation cancelled");
            return;
          }

          setMessage("Decrypting card attributes...");

          const res = await instance.userDecrypt(
            [
              { handle: attackHandle, contractAddress: thisCardFusionAddress },
              {
                handle: defenseHandle,
                contractAddress: thisCardFusionAddress,
              },
              { handle: rarityHandle, contractAddress: thisCardFusionAddress },
              {
                handle: specialPowerHandle,
                contractAddress: thisCardFusionAddress,
              },
            ],
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          setMessage("Decryption completed successfully!");

          if (isStale()) {
            setMessage("Decryption operation cancelled");
            return;
          }

          const attributes: CardAttributes = {
            attack: {
              handle: attackHandle,
              clear: res[attackHandle as `0x${string}`],
            },
            defense: {
              handle: defenseHandle,
              clear: res[defenseHandle as `0x${string}`],
            },
            rarity: {
              handle: rarityHandle,
              clear: res[rarityHandle as `0x${string}`],
            },
            specialPower: {
              handle: specialPowerHandle,
              clear: res[specialPowerHandle as `0x${string}`],
            },
          };

          setCardAttributes((prev) => {
            const next = new Map(prev);
            next.set(thisCardId, attributes);
            return next;
          });

          setMessage("Card attributes revealed successfully!");
        } catch (e) {
          setMessage(`Decryption failed. Please try again.`);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      run();
    },
    [
      fhevmDecryptionSignatureStorage,
      ethersSigner,
      ethersReadonlyProvider,
      cardFusion.address,
      cardFusion.abi,
      instance,
      chainId,
      sameChain,
      sameSigner,
      cardAttributes,
    ]
  );

  return {
    contractAddress: cardFusion.address,
    canMint,
    canFuse,
    canDecrypt,
    mintCard,
    fuseCards,
    decryptCardAttributes,
    refreshMyCards,
    message,
    myCards,
    cardAttributes,
    isMinting,
    isFusing,
    isDecrypting,
    isRefreshing,
    isDeployed,
  };
};

